<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        .box1 {
            width: 300px;
            height: 300px;
            background-color: yellow;
        }

        .box2 {
            width: 200px;
            height: 200px;
            background-color: blue;
        }

        .box3 {
            width: 100px;
            height: 100px;
            background-color: red;
        }
    </style>
</head>

<body>
    <div class="box1">
        <div class="box2">
            <div class="box3"></div>
        </div>
    </div>
    <script>
        var box1 = document.querySelector(".box1");
        var box2 = document.querySelector(".box2");
        var box3 = document.querySelector(".box3");

        // box1.addEventListener("click", function () {
        //     console.log("我是box1")
        // })
        // box2.addEventListener("click", function () {
        //     console.log("我是box2")
        // })
        // box3.addEventListener("click", function () {
        //     console.log("我是box3")
        // })


        //通过上面的例子我们可以看到，事件是从最内层开始触发，然后依次向外，输出的顺序是
        //box3-box2-box1。导致这种顺序的原因是因为：事件流有事件捕获阶段和事件冒泡阶段，
        //事件捕获阶段是从最外层元素开始一层一层进入到事件目标（也就是我们点击的那个元素），
        //到达事件目标后，进入事件冒泡阶段，事件从最内层流向最外层，事件默认情况下在冒泡阶段触发
        //所以我们看到的是先输出box3,最后输出box1。


        box1.addEventListener("click", function () {
            console.log("我是box1")
        }, true)
        box2.addEventListener("click", function () {
            console.log("我是box2")
        }, true)
        box3.addEventListener("click", function () {
            console.log("我是box3")
        }, true)
        //只要在添加事件方法中添加第三个参数为true,事件就会在捕获阶段被触发，这样输出的顺序
        //就变成了box1-box2-box3。但是在日常开发中，我们几乎不用做此修改，让事件在冒泡阶段触发就可以了。
    
    
        
    </script>
</body>

</html>